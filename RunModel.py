# -*- coding: utf-8 -*-
#     Author: Yoshi Goto

import os
import tellurium as te
import numpy as np
import math
from matplotlib import pyplot as plt
import imp
import pandas as pd
from pathlib import Path

# TODO: Make a table of appropriate ranges for parameters.

def run_model(antStr,noiseLevel,inputData=None,genesToExport=None,perturb=None,exportData=None,bioTap='',
              savePath='results',fileName = '',showTimePlots=False,seed=0,drawModel=None):
    """
    Checks if Antimony models will reach steady-state, generates visualizations, and exports data.

    Arguments:
        antStr (str) :
            - The Antimony model.

        noiseLevel (float):
            - level of noise as a decimal. Ex: `0.05` = 5%

        inputData (list: [inputVal,maxTime,resolution]) :
            - **inputVal** (float) : The initial concentration of the input species (name in model: INPUT). Default: 1
            - **maxTime** (int) : Duration of minutes to simulate model. Default: 100
            - **resolution** (int) : The resolution of datapoints. Eg: If resolution = 5, the data will include data every 5 minutes. Default: 1

        perturb (list: [pertSpecies, pertType, mean, stdev]) :
            - **pertSpecies** (int list) : Which species to perturb, if perturbation is necessary. Default: 0
            - The following are parameters needed for perturbation of species. They are **optional** inputs.
              You can just supply pertSpecies, or pertSpecies and pertType, and the rest will use default parameters.
            - **pertType** (str) : either `UP` or `DOWN` or `KO` used as a flag for upregulation, repression, or knockout, respectively. Default: 'UP'
            - **mean** (int list) [mean,accuracy]: The mean value used in `np.random.normal` to generate a random perturbation, along with an accuracy value (in ##%) Default: [35,15]
            - **stdev** (float) : The stdev value used in `np.random.normal` to generate a random pertrubation. Default: 4

        genesToExport (list: [genesToExport,speciesType]) :
            - **genesToExport** (int list): Which genes you want to export. Pass in [0] to export all proteins or mRNA. Default: [0]
            - **speciesType** (str) : `P`rotein or `M`rNA. Default: 'P'

        exportData (list: [sbml, antimony]) :
            - **antimony** (bool) : This is a flag for the export of the Antimony model as a txt. Default:True
            - **sbml** (bool) : This is a flag for the export of the model in SBML format (version based on Tellurium). Default:False


        bioTap (str):
            - If this is not empty, a csv file to use for BioTapestry will be exported. Default: ''

        savePath (str):
            - All output files will be saved to `current_working_directory\savePath\modelName\` . Default: 'results'

        fileName (str):
            - A name that will prefix all filenames generated by the script. Default: Name of model taken from antStr

        showTimePlots (bool):
            - Flag for if you want plots to be generated and saved. Default: False

        seed (int):
            - Seed for reproducibility purposes when generating random data. Default: 0

        drawModel (bool):
            - Generates a graph with PyGraphViz. Requires pygraphviz and graphviz installed Default: False

    Outputs:
        - model (model object): Roadrunner instance of the model.
        - result (np.array): Numpy matrix of the result data
        - resultNoisy (np.array): Numpy matrix of the result data (Noisy)
    """

    # Creating default lists
    if inputData is None:
        inputData = [1,100,1]

    if exportData is None:
        exportData = [True,False]

    if drawModel is None:
        drawModel = [False,'fdp']

    if genesToExport is None:
        genesToExport = [[0],'P']

    if perturb is None:
        perturb = [0]
    if len(perturb) == 1:
        perturb = [perturb,'UP',[0,0],0]
    if len(perturb) == 2:
        perturb = [perturb, [35,15], 4]

    #error catching
    if genesToExport[1] not in ['P','M']:
        raise ValueError("Output data type not recognized (must be P or M)")

    # Load the Antimony string as a model
    try:
        model = te.loadAntimonyModel(antStr)
        print('Successfully loaded in Antimony string as a model.')
    except Exception as error:
        ErrorPrinting(error)
        raise RuntimeError("Failed to load antimony string due to parsing error. Check that your antStr is correct.")

    # Check that the model reaches steady-state. If the model has any issues running, it will raise an Exception.
    # If an exception is reached, the user should run get_model again.
    plt.close('all')
    model.resetToOrigin()
    tStep = int(math.ceil(inputData[1]/inputData[2]))
    try:
        model.steadyState()
    except Exception:
        try:
            model.conservedMoietyAnalysis = True
            model.steadyState()
        except Exception as error:
            print ("Failed to reach steady-state or there is an Integrator error. Check your model or run get_model again.")
            ErrorPrinting(error)
            raise error

    # reset model
    model.resetToOrigin()

    # specify input
    model.INPUT = inputData[0];

    # specify perturbations
    if perturb != 0 and not 0 in perturb[0]: #i.e. not wild-type
        pertSpecies = perturb[0]

        pertType = perturb[1]
        mean = perturb[2]
        stdev = perturb[3]
        for species in pertSpecies:

            if pertType == 'KO':
                exec('model.Vm' + str(species)  + ' = 0') in locals(), globals()
                exec('model.d_mRNA' + str(species)  + ' = 0') in locals(), globals()
                exec('model.d_protein' + str(species)  + ' = 0') in locals(), globals()
                exec('model.mRNA' + str(species)  + ' = 1E-9') in locals(), globals()
                exec('model.P' + str(species)  + ' = 1E-9') in locals(), globals()
                exec('model.L' + str(species)  + ' = 0') in locals(), globals()
                #change initVals to 1E-9 instead of 0 to prevent possible solver hanging bug
            
            else:
                currVm = eval('model.Vm' + str(species))

                randPert = mean[0]
                if mean[1]!=0:
                    randPert = np.random.normal(mean[0],stdev)
                    while mean[0] - mean[1] > randPert or randPert > mean[0] + mean[1]:
                        randPert = np.random.normal(mean[0],stdev)
                        while randPert >= 0:
                            randPert = np.random.normal(mean[0],stdev)
                randPert /= 100.0

                if pertType == 'UP':
                    newVal = currVm * (1 + randPert)
                    exec('model.Vm' + str(species) +  ' = ' + str(newVal)) in locals(), globals()
                if pertType == 'DOWN':
                    newVal = currVm * (1 - randPert)
                    exec('model.Vm' + str(species)  +  ' = ' + str(newVal)) in locals(), globals()

    # Construct the selection arguments for simulation
    exportSpecies = genesToExport[0]
    species_type = genesToExport[1]

    if exportSpecies==0:
        allGenes = int((model.getNumFloatingSpecies() - 1)/2)
        if species_type == 'P':
            selections = ["P" + str(i+1) for i in range(allGenes)]
        elif species_type == 'M':
            selections = ["mRNA" + str(i+1) for i in range(allGenes)]
    else:
        if species_type == 'P':
            selections = ["P" + str(i) for i in exportSpecies]
        elif species_type == 'M':
            selections = ["mRNA" + str(i) for i in exportSpecies]

    selections = ['time'] + selections

    # Run a simulation for time-course data
    result = model.simulate(0,inputData[1],tStep+1,selections=selections)

    # Retrieve model name
    if fileName == '':
        fileName = model.getInfo().split("'modelName' : ")[1].split("\n")[0]

    # Specify (and make if necessary) a folder to save outputs to
    
    folderPath = Path(os.getcwd()) / savePath 
    if not os.path.exists(folderPath):
        os.mkdir(folderPath)
    print('\nFolder created: ' + folderPath.name)
    #fileName = fileName + '_'

    # Create results with artificial noise
    if noiseLevel != '0':
        resultNoisy = np.zeros([len(result[:,0]), len(result[0,:])])
        for k in range(len(result[:,0])):
            for i in range(len(result[0])):
                if i == 0:
                    resultNoisy[k,i] = result[k,i]
                else:
                    CurrVal = -1
                    while CurrVal < 0:
                        CurrVal = result[k,i] + np.random.normal(0,noiseLevel*result[k,i])
                    resultNoisy[k,i] = CurrVal

    # Export datasets
    Output(exportData,model,seed,selections,result,noiseLevel,resultNoisy, folderPath, fileName, antStr,bioTap)

    # Create graphs
    if showTimePlots:
        data = {next_name:resultNoisy[:,i] for i,next_name in enumerate(selections)}
        df = pd.DataFrame.from_dict(data)
        df.set_index('time', inplace=True)
        df.plot() 
        plt.title("Noisy Data")
        plt.xlabel("time")
        plt.savefig(folderPath / (fileName +'_Simulation_Noisy_Plot.png'), dpi=400)

        data = {next_name:result[:,i] for i,next_name in enumerate(selections)}
        df = pd.DataFrame.from_dict(data)
        df.set_index('time', inplace=True)
        df.plot()
        plt.title("Clean Data")
        plt.xlabel("time")
        plt.savefig(folderPath / (fileName +'_Simulation_Plot.png'), dpi=400)

    # Draw the model (requires pygraphviz module)
    if drawModel[0]:
        try:
            imp.find_module('pygraphviz')
            model.draw(layout=str(drawModel[1]))
        except ImportError:
            print('pygraphviz is not installed!')

    #returns the model, and result and/or resultNoisy arrays
    return(model,result,resultNoisy)

#### END MAIN FUNCTION ####

def Output(exportData,model,seed,selections,result,noiseLevel,resultNoisy,folderPath, fileName, antStr,bioTap):
#    export csv of results
    data = {next_name:result[:,i] for i, next_name in enumerate(selections)}
    df = pd.DataFrame.from_dict(data)
    df.set_index('time', inplace=True)

    df.to_csv(folderPath / (fileName + "Result_Clean.csv"))
    if noiseLevel != 0:
        data = {next_name:resultNoisy[:,i] for i, next_name in enumerate(selections)}
        df = pd.DataFrame.from_dict(data)
        df.set_index('time', inplace=True)
        df.to_csv(folderPath / (fileName + ".csv"))
#     export csv file for importing into Biotapestry
    if bioTap != '':
        f2 = open(folderPath / ("biotapestry.csv"), 'w')
        f2.write(bioTap)
        f2.close()
    # export Antimony model text
    if exportData[0]:
        if os.path.exists(folderPath / ("antimony.txt")):
            print('\nWarning: antimony.txt already exists! Preventing overwrite.' )
            exportData[1] == False
        else:
            fh = open(folderPath / ("antimony.txt"), 'w')
            fh.write(str(antStr))
            fh.close()
    # export SBML model text
    if exportData[1]:
        sbmlStr = model.getSBML()
        te.saveToFile (folderPath / ("SBML.xml"), sbmlStr)
    print('\nExport Data Saved!\n')

    # Attepts to print meaningful Errors
def ErrorPrinting(Error,customHeader=''):
    errorStr = str(Error)
    print('!'*len(errorStr))
    print(customHeader + errorStr)
    print('!'*len(errorStr))
    return()
